# Компоненты Kubernetes

## Расчет требований к кластеру

### 1. Исходное потребление
* **БД (3 реплики)**: 3 × (4 GB RAM, 1 vCPU) = 12.00 GB, 3.0 vCPU
* **Кеш (3 реплики)**: 3 × (4 GB, 1 vCPU) = 12.00 GB, 3.0 vCPU
* **Frontend (5 копий)**: 5 × (0.05 GB, 0.2 vCPU) = 0.25 GB, 1.0 vCPU
* **Backend (10 копий)**: 10 × (0.6 GB, 1 vCPU) = 6.00 GB, 10.0 vCPU

- **RAM_total** = 12 + 12 + 0.25 + 6 = 30.25 GB
- **CPU_total** = 3 + 3 + 1 + 10 = 17.0 vCPU

### 2. Выбираем средний тип ноды: (8 vCPU / 16 GB) × 5

### 3. Добавление резерва для безопасной эксплуатации(всплески, rolling updates и тд.)

**buffer = 20%** 

- **RAM_buffer** = 30.25 × 1.20 = 36.30 GB
- **CPU_buffer** = 17.0 × 1.20 = 20.40 vCPU

### 4. Добавления системного резерва

**CPU reservation:**

* 6% от первого ядра = 0.06
* 1% от второго ядра = 0.01
* 0.5% от 3-го и 4-го = 0.005 × 2 = 0.01
* 0.25% от каждого ядра свыше 4 = 0.0025×4 = 0.01
* **CPU_reserved = 0.06 + 0.01 + 0.01 + 0.01 = 0.09 vCPU**
* **usable CPU на ноду = 8 − 0.09 = 7.91 vCPU**

**Memory reservation:**

* 25% от первых 4 GB = 1.00 GB
* 20% от следующих 4 GB = 0.80 GB 
* 10% от следующих 8 GB = 0.80 GB
* порог удаления 100 MB 
* **RAM_reserved = 1 + 0.8 + 0.8 + 0.1 = 2.7 GB**
* **usable RAM на ноду = 16 − 2.7 = 13.3 GB**

[Architecting Kubernetes clusters — choosing a worker node size.](https://learnkube.com/kubernetes-node-size)

### 5. Суммарные ресурсы при отказе 1 ноды

* Всего usable CPU = 5 × 7.91 = 39.55 vCPU
* Всего usable RAM = 5 × 13.3 = 66.5 GB

**При отказе 1 ноды:**

* usable CPU = 4 × 7.91 = 31.64 vCPU
* usable RAM = 4 × 13.3 = 53.2 GB

**Сравнение с требованиями:**

* До отказа: CPU 39.55/20.4; RAM 66.5/36.3 — покрывает требования с запасом
* После отказа: CPU 31.64/20.4; RAM 53.2/36.3 — покрывает требования с запасом.

**Утилизация:**

* До отказа: CPU 20.4/39.55 = 51.6%, RAM 36.3/66.25 = 55%
* После отказа: CPU 20.4/31.64 = 64.4%, RAM 36.3/53.2 = 68%

**Вывод:** (8 vCPU / 16 GB) × 5 - ресурсы используются эффективно, при отказе 1 ноды остаётся приличный запас CPU/RAM. Для отказоустойчивости требуется `podAntiAffinity` для DB и кеша, чтобы реплики шли на разные ноды. В манифестах указывать `requests` и `limits` для корректного размещения.
